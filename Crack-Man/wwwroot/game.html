<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>SimulationView</title>
</head>
<body style="margin:0px;padding:0px;overflow:hidden;">

    <progress id="health" value="150" max="150"></progress>  <audio controls autoplay style="visibility:hidden"><source src="audio/music.mp3" type="audio/mpeg"></audio><p id="Points">Points</p>
    <script>

        function parseCommand(input = "") {
            return JSON.parse(input);
        }

        var exampleSocket;

        window.onload = function () {


            //variables
            let health = document.getElementById("health");
            var worldObjects = {};
            var camera, scene, renderer;
            var cameraControls;
            var cmbox;
            var cmmodel;
            var cameratype;

            var collidableWallList = [];
            var collidablePillList = [];
            var collidableEnemyList = [];
            var collidableSpeedList = [];
            var collidableShroomList = [];
            var pills = [];
            var speeds = [];
            var shrooms = [];
            var wallCollision = false;
            var enemyCollision = false;

            var skyboxMaterials;
            var tripbox;
            var skybox;
            var tripplane;
            var plane;
            var speed = 0.2;
            var move = 'stop';
            var pointss = 0;
            var direction;
            var idle;
            var superspeed = false;
            var supertrip = false;
            var superhigh = false;
            var counter = 0;
            var counter2 = 0;
            init();
            animate();

            //functions
            function init() {

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
                cameraControls = new THREE.OrbitControls(camera);
                camera.position.z = -20;
                camera.position.y = 40;
                camera.position.x = 50;
                cameratype = 1;
                camera.lookAt(50, 0, 37.5);
                cameraControls.update();

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight + 5);
                document.body.appendChild(renderer.domElement);
                window.addEventListener('resize', onWindowResize, false);

                //generating plane
                var geometry = new THREE.PlaneGeometry(100, 75, 32);
                var material = new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/platje.png"), side: THREE.DoubleSide });
                plane = new THREE.Mesh(geometry, material);
                plane.rotation.x = Math.PI / 2.0;
                plane.position.x = 50;
                plane.position.z = 37.5;
                scene.add(plane);
                tripplane = new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.DoubleSide });

                //generating skybox
                var skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
                skyboxMaterials =
                    [
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }), //front side
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }), //back side
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }), //top side
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }), //bottom side
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }), //right side
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }) //left side
                    ];
                var skyboxMaterial = new THREE.MeshFaceMaterial(skyboxMaterials);
                skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                skybox.position.y = 499;
                scene.add(skybox);

                //trippy skybox
                tripbox = [
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }), //front side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }), //back side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }), //top side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }), //bottom side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }), //right side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }) //left side
                ];

                //soft white light
                var light = new THREE.AmbientLight(0x404040);
                scene.add(light);

                //White directional light at 70% intensity shining from the top.
                var directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
                scene.add(directionalLight);

                ////walls     x,  y,  z , length, angle
                ////VERTIKAAL
                ////kolom 1
                //createWall(3, 0.8, 13, 25, 90);
                //createWall(3, 0.8, 13, 25, 90);


                ////kolom 2
                //createWall(18, 0.8, 13, 25, 90);
                //createWall(18, 0.8, 13, 25, 90);


                ////kolom 3
                //createWall(25, 0.8, 13, 25, 90);


                ////kolom 4 nieuw



                ////kolom 5
                //createWall(50, 0.8, 13, 25, 90);
                //createWall(50, 0.8, 13, 25, 90);
                //createWall(50, 0.8, 13, 25, 90);
                //createWall(50, 0.8, 13, 25, 90);


                ////kolom 6 nieuw



                ////kolom 7
                //createWall(74, 0.8, 13, 25, 90);
                //createWall(74, 0.8, 13, 25, 90);


                ////kolom 8
                //createWall(82, 0.8, 13, 25, 90);
                //createWall(82, 0.8, 13, 25, 90);


                ////kolom 9
                //createWall(97, 0.8, 13, 25, 90);
                //createWall(97, 0.8, 13, 25, 90);
                ////HORIZONTAAL
                ////rij 1
                //createWall(50, 0.8, 3, 20, 180);


                ////rij 2
                //createWall(50, 0.8, 11, 20, 180);
                //createWall(50, 0.8, 11, 20, 180);
                //createWall(50, 0.8, 11, 20, 180);
                //createWall(50, 0.8, 11, 20, 180);


                ////rij 3
                //createWall(50, 0.8, 20, 20, 180);
                //createWall(50, 0.8, 20, 20, 180);
                //createWall(50, 0.8, 20, 20, 180);


                ////rij 4
                //createWall(50, 0.8, 27, 20, 180);
                //createWall(50, 0.8, 27, 20, 180);
                //createWall(50, 0.8, 27, 20, 180);
                //createWall(50, 0.8, 27, 20, 180);


                ////rij 5
                //createWall(50, 0.8, 34, 20, 180);
                //createWall(50, 0.8, 34, 20, 180);
                //createWall(50, 0.8, 34, 20, 180);


                ////rij 6
                //createWall(50, 0.8, 41, 20, 180);
                //createWall(50, 0.8, 41, 20, 180);
                //createWall(50, 0.8, 41, 20, 180);

                ////rij 7
                //createWall(50, 0.8, 48, 20, 180);
                //createWall(50, 0.8, 48, 20, 180);
                //createWall(50, 0.8, 48, 20, 180);
                //createWall(50, 0.8, 48, 20, 180);


                ////rij 8
                //createWall(50, 0.8, 55, 20, 180);
                //createWall(50, 0.8, 55, 20, 180);
                //createWall(50, 0.8, 55, 20, 180);


                ////rij 9
                //createWall(50, 0.8, 64, 20, 180);
                //createWall(50, 0.8, 64, 20, 180);
                //createWall(50, 0.8, 64, 20, 180);
                //createWall(50, 0.8, 64, 20, 180);


                ////rij 10
                //createWall(50, 0.8, 72, 100, 180);

                //crackman model
                loadOBJModel("models/", "crackman.obj", "models/", "crackman.mtl", (mesh) => {
                    cmmodel = mesh;
                    cmmodel.scale.set(.08, .08, .08);
                    cmmodel.position.x = 46.5;
                    cmmodel.position.y = -0.2;
                    cmmodel.position.z = 5;
                    scene.add(cmmodel)
                });

                //CRACKMAN HITBOX
                var cubeGeometry = new THREE.CubeGeometry(3, 3, 3, 1, 1, 1);
                var wireMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0 });
                cmbox = new THREE.Mesh(cubeGeometry, wireMaterial);
                cmbox.position.set(46.5, 0.6, 5);
                scene.add(cmbox);

                //spawn basic pills
                for (var x = 0; x < 15; x++) {
                    pickupspawn(1 + (x * 7), -1, 'v');
                }

                //spawn speed
                spawnSpeeds(9.5, 23);
                spawnSpeeds(47, 16);
                spawnSpeeds(84, 7);
                spawnSpeeds(40, 59);
                spawnSpeeds(17, 69);
                spawnSpeeds(71.5, 54);

                //spawn shrooms
                spawnShrooms(67, 24);
                spawnShrooms(93, 65);
                spawnShrooms(8, 37);
            }

            //things in here get updated
            function update() {

                if (supertrip == true) {
                    counter2 += 1;
                    plane.material = tripplane;
                    skybox.material = new THREE.MeshFaceMaterial(tripbox);

                    if (counter2 == 150) {
                        supertrip = false;
                        counter2 = 0;
                        plane.material = new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/platje.png"), side: THREE.DoubleSide });
                        skybox.material = new THREE.MeshFaceMaterial(skyboxMaterials);
                    }
                }

                if (superspeed == true) {
                    counter += 1;
                    speed = 0.6;
                    if (counter == 150) { superspeed = false; counter = 0; speed = 0.2; }
                }

                if (cmmodel.position.y > 0.6) {
                    if (superspeed == true) { idle = -0.15 } else { idle = -0.04; }
                }
                if (cmmodel.position.y < -0.1) {
                    if (superspeed == true) { idle = 0.15 } else { idle = 0.04; }
                }
                cmmodel.position.y += idle;

                for (var i = 0; i < pills.length; i++) {
                    rotate(pills[i]);
                }
                for (var i = 0; i < speeds.length; i++) {
                    speeds[i].rotation.z = speeds[i].rotation.z + 0.15;
                }
                for (var i = 0; i < shrooms.length; i++) {
                    shrooms[i].rotation.y = shrooms[i].rotation.y + 0.03;
                }

                document.getElementById("Points").innerHTML = pointss + " Points";
                if (health.value < 1) {
                    health.value = 150;
                    //reset();
                }

                var map = {};
                onkeydown = onkeyup = function (e) {
                    e = e || event;
                    map[e.keyCode] = e.type == 'keydown';

                    if (map[87]) //w
                    {
                        move = 'up';
                    }
                    else if (map[83]) //s
                    {
                        move = 'down';
                    }
                    else if (map[65])//a
                    {
                        move = 'left';
                    }
                    else if (map[68])//d
                    {
                        move = 'right';
                    }
                    if (map[82])//R to reset
                    {
                        health.value = 150;
                        reset();
                    }
                    if (map[32])//SPACEBAR to switch between cameras
                    {
                        cameratype += 1;
                        if (cameratype == 4) { cameratype = 1; }
                    }
                    if (map[188] && speed >= 0.4) // < to go slower
                    {
                        speed -= 0.1;
                    }
                    else if (map[190]) // > to go faster
                    {
                        speed += 0.1;
                    }
                }

                //collision check cmbox with the meshes in collidable lists
                var originPoint = cmbox.position.clone();
                for (var vertexIndex = 0; vertexIndex < cmbox.geometry.vertices.length; vertexIndex++) {
                    var localVertex = cmbox.geometry.vertices[vertexIndex].clone();
                    var globalVertex = localVertex.applyMatrix4(cmbox.matrix);
                    var directionVector = globalVertex.sub(cmbox.position);
                    var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());

                    var wallCollisionResults = ray.intersectObjects(collidableWallList);
                    if (wallCollisionResults.length > 0 && wallCollisionResults[0].distance < directionVector.length()) //collision detected with wall
                    {
                        wallCollision = true;
                    }

                    for (var i = 0; i < collidablePillList.length; i++) {
                        var pillCollisionResults = ray.intersectObject(collidablePillList[i]);
                        if (pillCollisionResults.length > 0 && pillCollisionResults[0].distance < directionVector.length()) //collision detected with pill
                        {
                            pointss = pointss + 10;
                            collidablePillList[i].position.y = -1000;
                            pills[i].position.y = -1000;
                        }
                    }

                    var enemyCollisionResults = ray.intersectObjects(collidableEnemyList);
                    if (enemyCollisionResults.length > 0 && enemyCollisionResults[0].distance < directionVector.length()) //collision detected with enemy
                    {
                        enemyCollision = true;
                    }

                    for (var i = 0; i < collidableSpeedList.length; i++) {
                        var speedCollisionResults = ray.intersectObject(collidableSpeedList[i]);
                        if (speedCollisionResults.length > 0 && speedCollisionResults[0].distance < directionVector.length()) //collision detected with speed
                        {
                            collidableSpeedList[i].position.y = -1000;
                            speeds[i].position.y = -1000;
                            superspeed = true;
                        }
                    }
                    for (var i = 0; i < collidableShroomList.length; i++) {
                        var shroomCollisionResults = ray.intersectObject(collidableShroomList[i]);
                        if (shroomCollisionResults.length > 0 && shroomCollisionResults[0].distance < directionVector.length()) //collision detected with mushroom
                        {
                            collidableShroomList[i].position.y = -1000;
                            shrooms[i].position.y = -1000;
                            supertrip = true;
                        }
                    }
                }

                //move crackman if there is no collision
                if (wallCollision == false) {
                    if (move == 'up') {
                        cmbox.position.z += speed;
                        cmbox.rotation.y = (Math.PI / 180) * 0;
                    }
                    else if (move == 'down') {
                        cmbox.position.z -= speed;
                        cmbox.rotation.y = (Math.PI / 180) * 180;
                    }
                    else if (move == 'left') {
                        cmbox.position.x += speed;
                        cmbox.rotation.y = (Math.PI / 180) * 90;
                    }
                    else if (move == 'right') {
                        cmbox.position.x -= speed;
                        cmbox.rotation.y = (Math.PI / 180) * 270;
                    }
                }

                //if there is collision with walls, move crackman 1 step back opposite to the direction he's facing and stop moving in that direction
                if (wallCollision == true) {

                    if (cmbox.rotation.y == (Math.PI / 180) * 0) { //w
                        cmbox.position.z -= speed;
                        move = 'stop';
                    }
                    else if (cmbox.rotation.y == (Math.PI / 180) * 90) { //a
                        cmbox.position.x -= speed;
                        move = 'stop';
                    }
                    else if (cmbox.rotation.y == (Math.PI / 180) * 180) { //s
                        cmbox.position.z += speed;
                        move = 'stop';
                    }
                    else if (cmbox.rotation.y == (Math.PI / 180) * 270) { //d
                        cmbox.position.x += speed;
                        move = 'stop';
                    }
                    wallCollision = false;
                }

                cameraControls.update();

                //make crackman follow its hitbox
                cmmodel.position.x = cmbox.position.x;
                cmmodel.position.z = cmbox.position.z;
                cmmodel.rotation.y = cmbox.rotation.y;
            }

            //generates a wall
            function createWall(setx, sety, setz, length, rotation) {
                var wallGeometry = new THREE.CubeGeometry(length, 1.5, 4, 1, 1, 1);
                var wallMaterial = new THREE.MeshBasicMaterial({ color: 0x003366 });
                var wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(setx, sety, setz);
                wall.rotation.y = ((Math.PI / 180) * rotation);
                scene.add(wall);
                collidableWallList.push(wall);
            }

            //generate standard pills
            function pickupspawn(setx, setz, direction) {
                for (var i = 0; i < 14; i++) {
                    loadOBJModel("models/", "pill.obj", "models/", "pill.mtl", (mesh) => {
                        pills.push(mesh);
                        mesh.scale.set(.006, .006, .006);
                        scene.add(mesh);
                        if (direction == 'h') {
                            setx += 5;
                            mesh.position.x = setx;
                            mesh.position.y = 0.6;
                            mesh.position.z = setz;
                        }
                        if (direction == 'v') {
                            setz += 5;
                            mesh.position.x = setx;
                            mesh.position.y = 1;
                            mesh.position.z = setz;
                        }
                        var pillcGeometry = new THREE.CubeGeometry(3, 2, 2, 1, 1, 1);
                        var pillcMaterial = new THREE.MeshBasicMaterial({ color: 0x003366, transparent: true, opacity: 0 });
                        var pillc = new THREE.Mesh(pillcGeometry, pillcMaterial);
                        pillc.position.x = mesh.position.x;
                        pillc.position.y = mesh.position.y;
                        pillc.position.z = mesh.position.z;
                        scene.add(pillc);
                        collidablePillList.push(pillc);

                    });
                }
            }

            //generate speed pills
            function spawnSpeeds(setx, setz) {
                loadOBJModel("models/", "speed.obj", "models/", "speed.mtl", (mesh) => {
                    speeds.push(mesh);
                    mesh.scale.set(15, 15, 15);
                    mesh.position.x = setx;
                    mesh.position.y = 2;
                    mesh.position.z = setz;
                    scene.add(mesh);

                    var Geometry = new THREE.CubeGeometry(3, 3, 3, 1, 1, 1);
                    var Material = new THREE.MeshBasicMaterial({ color: 0x003366, transparent: true, opacity: 0 });
                    var speedHitbox = new THREE.Mesh(Geometry, Material);
                    speedHitbox.position.x = mesh.position.x;
                    speedHitbox.position.y = mesh.position.y;
                    speedHitbox.position.z = mesh.position.z;
                    scene.add(speedHitbox);
                    collidableSpeedList.push(speedHitbox);
                });
            }
            //generate shrooms
            function spawnShrooms(setx, setz) {
                loadOBJModel("models/", "shroom.obj", "models/", "shroom.mtl", (mesh) => {
                    shrooms.push(mesh);
                    mesh.scale.set(0.3, 0.3, 0.3);
                    mesh.position.x = setx;
                    mesh.position.y = 0.2;
                    mesh.position.z = setz;
                    scene.add(mesh);

                    var Geometry = new THREE.CubeGeometry(3, 3, 3, 1, 1, 1);
                    var Material = new THREE.MeshBasicMaterial({ color: 0x003366, transparent: true, opacity: 0 });
                    var shroomHitbox = new THREE.Mesh(Geometry, Material);
                    shroomHitbox.position.x = mesh.position.x;
                    shroomHitbox.position.y = mesh.position.y;
                    shroomHitbox.position.z = mesh.position.z;
                    scene.add(shroomHitbox);
                    collidableShroomList.push(shroomHitbox);
                });
            }

            //lower hp when hit
            function gethit() {
                health.value -= 2;
            }
            //rotates items
            function rotate(a) {
                a.rotation.z = a.rotation.z + 0.01;
            }
            //does something
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            //animates stuff
            function animate() {
                requestAnimationFrame(animate);
                render();
                update();
            }

            //render the scene and camera
            function render() {
                cameras();
                renderer.render(scene, camera);
            }

            //reset crackman and the camera
            function reset() {
                cmbox.position.set(46.5, 0.6, 5);
                cmmodel.position.set(46.5, 0, 5);
                camera.position.z = -20;
                camera.position.y = 40;
                camera.position.x = 50;
                cameratype = 1;
                speed = 0.2;
                pointss = 0;
                move = 'stop';
                for (var i = 0; i < collidablePillList.length; i++) {
                    collidablePillList[i].position.y = 0.6;
                    pills[i].position.y = 0.6;
                }
                for (var i = 0; i < collidableSpeedList.length; i++) {
                    collidableSpeedList[i].position.y = 2;
                    speeds[i].position.y = 2;
                }
                for (var i = 0; i < collidableShroomList.length; i++) {
                    collidableShroomList[i].position.y = 3.5;
                    shrooms[i].position.y = 0.2;
                }

            }
            //switches between cameras
            function cameras() {

                if (cameratype == 1) { //free camera
                    camera.lookAt(50, 0, 37.5);
                }
                else if (cameratype == 2) { //3rd person camera
                    camera.lookAt(cmbox.position);
                    camera.position.z = cmbox.position.z - 10;
                    camera.position.y = cmbox.position.y + 10;
                    camera.position.x = cmbox.position.x;
                }
                else if (cameratype == 3) {  //1st person camera
                    camera.position.z = cmbox.position.z;
                    camera.position.y = cmbox.position.y;
                    camera.position.x = cmbox.position.x;
                    if (cmbox.rotation.y == (Math.PI / 180) * 0) {
                        camera.lookAt(cmbox.position.x, cmbox.position.y, cmbox.position.z + 3);
                    }
                    else if (cmbox.rotation.y == (Math.PI / 180) * 90) {
                        camera.lookAt(cmbox.position.x + 3, cmbox.position.y, cmbox.position.z);
                    }
                    else if (cmbox.rotation.y == (Math.PI / 180) * 180) {
                        camera.lookAt(cmbox.position.x, cmbox.position.y, cmbox.position.z - 3);
                    }
                    else if (cmbox.rotation.y == (Math.PI / 180) * 270) {
                        camera.lookAt(cmbox.position.x - 3, cmbox.position.y, cmbox.position.z);
                    }
                }
            }

            //object loader
            function loadOBJModel(modelPath, modelName, texturePath, textureName, onload) {
                new THREE.MTLLoader()
                    .setPath(texturePath)
                    .load(textureName, function (materials) {
                        materials.preload();

                        new THREE.OBJLoader()
                            .setPath(modelPath)
                            .setMaterials(materials)
                            .load(modelName, function (object) {
                                onload(object);
                            }, function () { }, function (e) { console.log("Error loading model"); console.log(e); });
                    });
            }
            exampleSocket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/connect_client");
            exampleSocket.onmessage = function (event) {
                var command = parseCommand(event.data);
            }
        }


    </script>
    <script src="three.min.js"></script>
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="MTLLoader.js"></script>
    <script src="OBJLoader.js"></script>

</body>
</html>
