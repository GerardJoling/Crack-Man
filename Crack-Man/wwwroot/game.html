<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Crack-Man</title>
</head>
<body style="margin:0px;padding:0px;overflow:hidden;">
    <script>
function parseCommand(input = "") {
            return JSON.parse(input);
        }

        var exampleSocket;

        window.onload = function () {


            //variables
            let score = document.getElementById("score");
            let health = document.getElementById("health");
            var worldObjects = {};
            var camera, scene, renderer;
            var cameraControls;
            var cmbox;
            var cmmodel;
            var cameratype;
            var collidableWallList = [];
            var collidablePillList = [];
            var collidableGhostList = [];
            var collidableSpeedList = [];
            var collidableShroomList = [];
            var collidableWeedList = [];
            var ghosts = [];
            var weeds = [];
            var pills = [];
            var speeds = [];
            var shrooms = [];
            var wallCollision = false;
            var enemyCollision = false;

            var skyboxMaterials;
            var tripbox;
            var skybox;
            var weedbox;
            var speed;
            var gspeed = 0.3;
            var speedModifier = 1;
            var move = 'stop';
            var pointss = 0;
            var life = 150;
            var direction;
            var idle;
            var sober = true;
            var superspeed = false;
            var supertrip = false;
            var superhigh = false;
            var speedcounter = 0;
            var shroomcounter = 0;
            var weedcounter = 0;
            var gmove = [];
           
            init();
            animate();

            //functions
            function init() {

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
                cameraControls = new THREE.OrbitControls(camera);
                camera.position.z = -20;
                camera.position.y = 40;
                camera.position.x = 50;
                cameratype = 2;
                camera.lookAt(50, 0, 37.5);
                cameraControls.update();

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight + 5);
                document.body.appendChild(renderer.domElement);
                window.addEventListener('resize', onWindowResize, false);
                for (var i = 0; i < 10; i++) {
                    gmove[i] = 'up';
                }

                //generating skybox
                var skyboxGeometry = new THREE.BoxGeometry(300, 300, 300);
                skyboxMaterials =
                    [
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }), //front side
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }), //back side
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }), //top side
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }), //bottom side
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }), //right side
                        new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }) //left side
                    ];

                var skyboxMaterial = new THREE.MeshFaceMaterial(skyboxMaterials);
                skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                skybox.position.y = 150;
                scene.add(skybox);

                //sober skybox
                starbox = [
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/stars.jpg"), side: THREE.BackSide }), //front side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/stars.jpg"), side: THREE.BackSide }), //back side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/stars.jpg"), side: THREE.BackSide }), //top side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/stars.jpg"), side: THREE.BackSide }), //bottom side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/stars.jpg"), side: THREE.BackSide }), //right side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/stars.jpg"), side: THREE.BackSide }) //left side
                ];
                //trippy skybox
                tripbox = [
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }), //front side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }), //back side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }), //top side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }), //bottom side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }), //right side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/trippy.jpg"), side: THREE.BackSide }) //left side
                ];
                //weed skybox
                weedbox = [
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/weed.jpg"), side: THREE.BackSide }), //front side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/weed.jpg"), side: THREE.BackSide }), //back side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/weed.jpg"), side: THREE.BackSide }), //top side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/weed.jpg"), side: THREE.BackSide }), //bottom side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/weed.jpg"), side: THREE.BackSide }), //right side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/weed.jpg"), side: THREE.BackSide }) //left side
                ];
                //speed skybox
                speedbox = [
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/speed.jpg"), side: THREE.BackSide }), //front side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/speed.jpg"), side: THREE.BackSide }), //back side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/speed.jpg"), side: THREE.BackSide }), //top side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/speed.jpg"), side: THREE.BackSide }), //bottom side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/speed.jpg"), side: THREE.BackSide }), //right side
                    new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/speed.jpg"), side: THREE.BackSide }) //left side
                ];
                //soft white light
                var light = new THREE.AmbientLight(0x404040);
                scene.add(light);

                //White directional light at 70% intensity shining from the top.
                var directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
                scene.add(directionalLight);

                //spawn crackman
                spawnCrackMan(46.5, 7);

                //spawn ghosts
                spawnGhost(9.5, 23);
                spawnGhost(47, 16);
                spawnGhost(84, 7);
                spawnGhost(40, 59);
                spawnGhost(17, 69);
                spawnGhost(70, 54);
                spawnGhost(70, 37);


                //spawn basic pills (x, z, direction, amount, distance)

                //kolom 1 & 9
                spawnPills(92.6, 7, 'v', 1, 4.85);
                spawnPills(92.6, 14.5, 'v', 1, 4.85);
                spawnPills(92.6, 50.5, 'v', 1, 4.85);
                spawnPills(92.6, 59, 'v', 1, 4.85);

                spawnPills(7, 7, 'v', 1, 4.85);
                spawnPills(7, 14.5, 'v', 1, 4.85);
                spawnPills(7, 50.5, 'v', 1, 4.85);
                spawnPills(7, 59, 'v', 1, 4.85);

                //kolom 2 & 8
                spawnPills(78.3, 7, 'v', 1, 4.85);
                spawnPills(78.3, 14.5, 'v', 1, 4.85);
                spawnPills(78.3, 22.5, 'v', 2, 4.85);
                spawnPills(78.3, 36, 'v', 2, 4.85);
                spawnPills(78.3, 50.5, 'v', 1, 4.85);
                spawnPills(78.3, 59, 'v', 1, 4.85);

                spawnPills(21.3, 7, 'v', 1, 4.85);
                spawnPills(21.3, 14.5, 'v', 1, 4.85);
                spawnPills(21.3, 23.5, 'v', 2, 4.85);
                spawnPills(21.3, 36, 'v', 2, 4.85);
                spawnPills(21.3, 50.5, 'v', 1, 4.85);
                spawnPills(21.3, 59, 'v', 1, 4.85);

                //kolom 3 & 7
                spawnPills(70.5, 14.5, 'v', 1, 4.85);
                spawnPills(70.5, 29, 'v', 1, 4.85);
                spawnPills(70.5, 36, 'v', 1, 4.85);
                spawnPills(70.5, 50.5, 'v', 1, 4.85);

                //spawnPills(29.6, 14.5, 'v', 1, 4.85);
                spawnPills(29.6, 29, 'v', 1, 4.85);
                spawnPills(29.6, 36, 'v', 1, 4.85);
                spawnPills(29.6, 50.5, 'v', 1, 4.85);

                //kolom 4 & 6
                spawnPills(54.2, 7, 'v', 1, 4.85);
                spawnPills(54.2, 22.5, 'v', 1, 4.85);
                spawnPills(54.2, 43, 'v', 1, 4.85);
                spawnPills(54.2, 59, 'v', 1, 4.85);

                spawnPills(46, 7, 'v', 1, 4.85);
                spawnPills(46, 22.5, 'v', 1, 4.85);
                spawnPills(46, 43, 'v', 1, 4.85);
                spawnPills(46, 59, 'v', 1, 4.85);

                //rij 1 & 9
                spawnPills(2, 7, 'h', 8, 4.85);
                spawnPills(49, 7, 'h', 9, 4.85);

                spawnPills(2, 68, 'h', 9, 4.85);
                spawnPills(49, 68, 'h', 9, 4.85);

                //rij 2 & 8
                spawnPills(2, 15.8, 'h', 9, 4.85);
                spawnPills(49, 15.8, 'h', 9, 4.85);

                spawnPills(2, 59.4, 'h', 9, 4.85);
                spawnPills(49, 59.4, 'h', 9, 4.85);

                //rij 3 & 7
                spawnPills(2, 24.1, 'h', 4, 4.85);
                spawnPills(24.4, 24.1, 'h', 4, 5.4);
                spawnPills(49, 24.1, 'h', 4, 5.4);
                spawnPills(73.5, 24.1, 'h', 4, 4.85);

                spawnPills(2, 51.1, 'h', 4, 4.85);
                spawnPills(24.4, 51.1, 'h', 4, 5.4);
                spawnPills(49, 51.1, 'h', 4, 5.4);
                spawnPills(73.5, 51.1, 'h', 4, 4.85);

                //rij 4 & 6
                spawnPills(24.4, 30, 'h', 4, 5.4);
                spawnPills(49, 30, 'h', 4, 5.4);

                spawnPills(24.4, 44, 'h', 4, 5.4);
                spawnPills(49, 44, 'h', 4, 5.4);

                //rij 5
                spawnPills(2, 38, 'h', 4, 4.85);
                spawnPills(21.3, 38, 'h', 2, 4.2);
                spawnPills(31.1, 38, 'h', 7, 4.7);
                spawnPills(65.9, 38, 'h', 2, 4.2);
                spawnPills(73.5, 38, 'h', 4, 4.85);


                //spawn walls (x, y, z, length, angle)

                //kolom 1 & 9
                createWall(3, 0.8, 14.5, 26.5, 90);
                createWall(3, 0.8, 60, 26.5, 90);

                createWall(97, 0.8, 14.5, 26.5, 90);
                createWall(97, 0.8, 60, 26.5, 90);

                //kolom 2 & 8
                createWall(18, 0.8, 30.5, 9.5, 90);
                createWall(18, 0.8, 44.5, 9.5, 90);

                createWall(82, 0.8, 30.5, 9.5, 90);
                createWall(82, 0.8, 44.5, 9.5, 90);

                //kolom 3 & 7
                createWall(25, 0.8, 26.5, 17.5, 90);
                createWall(25, 0.8, 48.5, 17.5, 90);

                createWall(74, 0.8, 26.5, 17.5, 90);
                createWall(74, 0.8, 48.5, 17.5, 90);

                //kolom 4 & 6
                createWall(32.5, 0.8, 37.5, 10.5, 90);

                createWall(67, 0.8, 37.5, 10.5, 90);

                //kolom 5
                createWall(50, 0.8, 8, 9.5, 90);
                createWall(50, 0.8, 24, 9.5, 90);
                createWall(50, 0.8, 51, 9.5, 90);
                createWall(50, 0.8, 67, 9.5, 90);

                //rij 1 & 10
                createWall(50, 0.8, 3, 96, 180);

                createWall(50, 0.8, 72, 96, 180);

                //rij 2 & 9
                createWall(14.5, 0.8, 11, 10.5, 180);
                createWall(34, 0.8, 11, 21, 180);
                createWall(65.5, 0.8, 11, 20, 180);
                createWall(86, 0.8, 11, 10.5, 180);

                createWall(14.5, 0.8, 64, 10.5, 180);
                createWall(34, 0.8, 64, 21, 180);
                createWall(65.5, 0.8, 64, 21, 180);
                createWall(86, 0.8, 64, 10.5, 180);

                //rij 3 & 8
                createWall(14.5, 0.8, 19.5, 10.5, 180);
                createWall(49.5, 0.8, 19.5, 38, 180);
                createWall(85.5, 0.8, 19.5, 10.5, 180);

                createWall(14.5, 0.8, 55.5, 10.5, 180);
                createWall(49.5, 0.8, 55.5, 38, 180);
                createWall(85.5, 0.8, 55.5, 10.5, 180);

                //rij 4 & 7
                createWall(10.5, 0.8, 27.5, 18.5, 180);
                createWall(34, 0.8, 27, 20, 180);
                createWall(65.5, 0.8, 27, 20, 180);
                createWall(89.5, 0.8, 27.5, 18.5, 180);

                createWall(10.5, 0.8, 47.5, 18.5, 180);
                createWall(34, 0.8, 48, 20, 180);
                createWall(65.5, 0.8, 48, 20, 180);
                createWall(89.5, 0.8, 47.5, 18.5, 180);

                //rij 5 & 6
                createWall(10, 0.8, 33.5, 19.5, 180);
                createWall(50, 0.8, 34, 32, 180);
                createWall(90, 0.8, 33.5, 19.5, 180);

                createWall(10, 0.8, 41.5, 19.5, 180);
                createWall(39.5, 0.8, 41, 16.5, 180);
                createWall(60, 0.8, 41, 16.5, 180);
                createWall(90, 0.8, 41.5, 19.5, 180);

                //spawn speed
                spawnSpeeds(9.5, 23);
                spawnSpeeds(50, 16);
                spawnSpeeds(84, 7);
                spawnSpeeds(40, 59);
                spawnSpeeds(17, 69);
                spawnSpeeds(70, 54);

                //spawn shrooms
                spawnShrooms(67, 24);
                spawnShrooms(93, 65);
                spawnShrooms(8, 37);

                //spawn weeds
                spawnWeeds(28, 20);
                spawnWeeds(15, 60);
                spawnWeeds(90, 15);
            }


            //things in here get updated
            function update() {
                health.value = life;
                score.value = pointss;
                speed = (0.3*speedModifier);

                //sober
                if (sober == true) {
                    weedcounter = 0;
                    speedcounter = 0;
                    shroomcounter = 0;
                    superspeed = false;
                    superhigh = false;
                    supertrip = false;
                    speedModifier = 1;
                    skybox.material = new THREE.MeshFaceMaterial(starbox);
                    cmmodel.scale.set(0.08, 0.08, 0.08);
                }

                //speed effect
                if (superspeed == true) {
                    speedcounter += 1;
                    speedModifier = 2;
                    skybox.material = new THREE.MeshFaceMaterial(speedbox);
                    skybox.rotation.y = skybox.rotation.y + 0.1;
                    cmmodel.scale.set(0.08, 0.08, 0.08);
                    if (speedcounter == 200) {
                        sober = true;
                    }
                }

                //shroom effect
                if (supertrip == true) {
                    shroomcounter += 1;
                    speedModifier = 1;
                    skybox.material = new THREE.MeshFaceMaterial(tripbox);
                    skybox.rotation.y = skybox.rotation.y + 0.01;
                    cmmodel.scale.set(0.2, 0.2, 0.2);
                    if (shroomcounter == 300) {
                        sober = true;
                    }
                }
                //weed effect
                if (superhigh == true) {
                    weedcounter += 1;
                    speedModifier = 0.4;
                    gspeed = 0.04
                    skybox.material = new THREE.MeshFaceMaterial(weedbox);
                    skybox.rotation.y = skybox.rotation.y + 0.0025;
                    cmmodel.scale.set(0.08, 0.08, 0.08);
                    if (weedcounter == 300) {
                        sober = true;
                    }
                }
                else { gspeed = 0.3;}
                //idle animations
                if (cmmodel.position.y > 0.6) {
                    idle = (-0.04*speedModifier);
                }
                if (cmmodel.position.y < -0.1) {
                    idle = (0.04*speedModifier);
                }
                cmmodel.position.y += (idle*speedModifier);
                for (var i = 0; i < pills.length; i++) {
                    rotate(pills[i]);
                }
                for (var i = 0; i < speeds.length; i++) {
                    speeds[i].rotation.z = speeds[i].rotation.z + (0.15*speedModifier);
                }
                for (var i = 0; i < shrooms.length; i++) {
                    shrooms[i].rotation.y = shrooms[i].rotation.y + (0.03*speedModifier);
                }
                for (var i = 0; i < weeds.length; i++) {
                    weeds[i].rotation.y = shrooms[i].rotation.y + (0.05*speedModifier);
                }

                //keyboard controls
                var map = {};
                onkeydown = onkeyup = function (e) {
                    e = e || event;
                    map[e.keyCode] = e.type == 'keydown';

                    if (map[87]) //w
                    {
                        move = 'up';
                    }
                    else if (map[83]) //s
                    {
                        move = 'down';
                    }
                    else if (map[65])//a
                    {
                        move = 'left';
                    }
                    else if (map[68])//d
                    {
                        move = 'right';
                    }
                    if (map[82])//R to reset
                    {
                        life = 150;
                        sober = true;
                        reset();
                    }
                    if (map[32])//SPACEBAR to switch between cameras
                    {
                        cameratype += 1;
                        if (cameratype == 3) { cameratype = 1; }
                    }
                    if (map[188] && speed >= 0.4) // < to go slower
                    {
                        speed -= 0.1;
                    }
                    else if (map[190]) // > to go faster
                    {
                        speed += 0.1;
                    }
                }
                //ghost collision with walls
                for (var i = 0; i < collidableGhostList.length; i++) {

                    var originPoint = collidableGhostList[i].position.clone();
                    for (var vertexIndex = 0; vertexIndex < collidableGhostList[i].geometry.vertices.length; vertexIndex++) {
                        var localVertex = collidableGhostList[i].geometry.vertices[vertexIndex].clone();
                        var globalVertex = localVertex.applyMatrix4(collidableGhostList[i].matrix);
                        var directionVector = globalVertex.sub(collidableGhostList[i].position);
                        var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());

                        var wallCollisionResults = ray.intersectObjects(collidableWallList);
                        if (wallCollisionResults.length > 0 && wallCollisionResults[0].distance < directionVector.length()) //collision detected with wall
                        {
                            var rndm = Math.random();
                            if (rndm <= 0.25) { gmove[i] = 'up'; }
                            else if (rndm <= 0.50 && rndm > 0.25) { gmove[i] = 'down'; }
                            else if (rndm <= 0.75 && rndm > 0.5) { gmove[i] = 'left'; }
                            else if (rndm <= 1 && rndm > 0.75) { gmove[i] = 'right'; }

                            if (collidableGhostList[i].rotation.y == (Math.PI / 180) * 0) { //w
                                collidableGhostList[i].position.z -= gspeed;

                            }
                            else if (collidableGhostList[i].rotation.y == (Math.PI / 180) * 90) { //a
                                collidableGhostList[i].position.x -= gspeed;

                            }
                            else if (collidableGhostList[i].rotation.y == (Math.PI / 180) * 180) { //s
                                collidableGhostList[i].position.z += gspeed;

                            }
                            else if (collidableGhostList[i].rotation.y == (Math.PI / 180) * 270) { //d
                                collidableGhostList[i].position.x += gspeed;

                            }

                        }
                    }
                    if (gmove[i] == 'up') {
                        collidableGhostList[i].position.z += gspeed;
                        collidableGhostList[i].rotation.y = (Math.PI / 180) * 0;
                    }
                    else if (gmove[i] == 'down') {
                        collidableGhostList[i].position.z -= gspeed;
                        collidableGhostList[i].rotation.y = (Math.PI / 180) * 180;
                    }
                    else if (gmove[i] == 'left') {
                        collidableGhostList[i].position.x += gspeed;
                        collidableGhostList[i].rotation.y = (Math.PI / 180) * 90;
                    }
                    else if (gmove[i] == 'right') {
                        collidableGhostList[i].position.x -= gspeed;
                        collidableGhostList[i].rotation.y = (Math.PI / 180) * 270;
                    }

                    ghosts[i].position.x = collidableGhostList[i].position.x;
                    ghosts[i].position.z = collidableGhostList[i].position.z;
                    ghosts[i].rotation.y = collidableGhostList[i].rotation.y;
                }

                //collision check crackmans hitbox (cmbox) with the meshes in the different collidable lists
                var originPoint = cmbox.position.clone();
                for (var vertexIndex = 0; vertexIndex < cmbox.geometry.vertices.length; vertexIndex++) {
                    var localVertex = cmbox.geometry.vertices[vertexIndex].clone();
                    var globalVertex = localVertex.applyMatrix4(cmbox.matrix);
                    var directionVector = globalVertex.sub(cmbox.position);
                    var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());

                    var wallCollisionResults = ray.intersectObjects(collidableWallList);
                    if (wallCollisionResults.length > 0 && wallCollisionResults[0].distance < directionVector.length()) //collision detected with wall
                    {
                        wallCollision = true;
                    }

                    for (var i = 0; i < collidablePillList.length; i++) {
                        var pillCollisionResults = ray.intersectObject(collidablePillList[i]);
                        if (pillCollisionResults.length > 0 && pillCollisionResults[0].distance < directionVector.length()) //collision detected with pill
                        {
                            pointss = pointss + 10;
                            collidablePillList[i].position.y = -1000;
                            pills[i].position.y = -1000;
                        }
                    }

                    var ghostCollisionResults = ray.intersectObjects(collidableGhostList);
                    if (ghostCollisionResults.length > 0 && ghostCollisionResults[0].distance < directionVector.length()) //collision detected with ghost
                    {
                        gethit();
                    }

                    for (var i = 0; i < collidableSpeedList.length; i++) {
                        var speedCollisionResults = ray.intersectObject(collidableSpeedList[i]);
                        if (speedCollisionResults.length > 0 && speedCollisionResults[0].distance < directionVector.length()) //collision detected with speed
                        {
                            collidableSpeedList[i].position.y = -1000;
                            speeds[i].position.y = -1000;
                            weedcounter = 300;
                            shroomcounter = 300;
                            speedcounter = 0;
                            sober = false;
                            superhigh = false;
                            supertrip = false;
                            superspeed = true;
                        }
                    }
                    for (var i = 0; i < collidableShroomList.length; i++) {
                        var shroomCollisionResults = ray.intersectObject(collidableShroomList[i]);
                        if (shroomCollisionResults.length > 0 && shroomCollisionResults[0].distance < directionVector.length()) //collision detected with mushroom
                        {
                            collidableShroomList[i].position.y = -1000;
                            shrooms[i].position.y = -1000;
                            weedcounter = 300;
                            speedcounter = 200;
                            shroomcounter = 0;
                            sober = false;
                            superspeed = false;
                            superhigh = false;
                            supertrip = true;
                        }
                    }
                    for (var i = 0; i < collidableWeedList.length; i++) {
                        var weedCollisionResults = ray.intersectObject(collidableWeedList[i]);
                        if (weedCollisionResults.length > 0 && weedCollisionResults[0].distance < directionVector.length()) //collision detected with weed
                        {
                            collidableWeedList[i].position.y = -1000;
                            weeds[i].position.y = -1000;
                            shroomcounter = 300;
                            speedcounter = 200;
                            weedcounter = 0;
                            sober = false;
                            superspeed = false;
                            supertrip = false;
                            superhigh = true;
                        }
                    }
                }

                //move crackman automatically if there is no collision
                if (wallCollision == false) {
                    if (move == 'up') {
                        cmbox.position.z += speed;
                        cmbox.rotation.y = (Math.PI / 180) * 0;
                    }
                    else if (move == 'down') {
                        cmbox.position.z -= speed;
                        cmbox.rotation.y = (Math.PI / 180) * 180;
                    }
                    else if (move == 'left') {
                        cmbox.position.x += speed;
                        cmbox.rotation.y = (Math.PI / 180) * 90;
                    }
                    else if (move == 'right') {
                        cmbox.position.x -= speed;
                        cmbox.rotation.y = (Math.PI / 180) * 270;
                    }
                }

                //if there is collision with walls, move crackman 1 step back opposite to the direction he's facing and stop moving in that direction
                if (wallCollision == true) {

                    if (cmbox.rotation.y == (Math.PI / 180) * 0) { //w
                        cmbox.position.z -= speed;
                        move = 'stop';
                    }
                    else if (cmbox.rotation.y == (Math.PI / 180) * 90) { //a
                        cmbox.position.x -= speed;
                        move = 'stop';
                    }
                    else if (cmbox.rotation.y == (Math.PI / 180) * 180) { //s
                        cmbox.position.z += speed;
                        move = 'stop';
                    }
                    else if (cmbox.rotation.y == (Math.PI / 180) * 270) { //d
                        cmbox.position.x += speed;
                        move = 'stop';
                    }
                    wallCollision = false;
                }


                cameraControls.update();

                //make crackman follow its hitbox
                if (cmbox.position.x <= 0) { cmbox.position.x = 99; }
                if (cmbox.position.x >= 100) { cmbox.position.x = 1; }
                cmmodel.position.x = cmbox.position.x;
                cmmodel.position.z = cmbox.position.z;
                cmmodel.rotation.y = cmbox.rotation.y;


            }

            //generates a wall
            function createWall(setx, sety, setz, length, rotation) {
                var wallGeometry = new THREE.CubeGeometry(length, 1.5, 3.5, 1, 1, 1);
                var wallMaterial = new THREE.MeshBasicMaterial({ color: 0x003366}); //, transparent: true, opacity: 0.5
                var wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(setx, sety, setz);
                wall.rotation.y = ((Math.PI / 180) * rotation);
                scene.add(wall);
                collidableWallList.push(wall);
            }

            //generate standard pills
            function spawnPills(setx, setz, direction, amount, distance) {
                for (var i = 0; i < amount; i++) {
                    loadOBJModel("models/", "pill.obj", "models/", "pill.mtl", (mesh) => {
                        pills.push(mesh);
                        mesh.scale.set(.006, .006, .006);
                        scene.add(mesh);
                        if (direction == 'h') {
                            setx += distance;
                            mesh.position.x = setx;
                            mesh.position.y = 0.6;
                            mesh.position.z = setz;
                        }
                        if (direction == 'v') {
                            setz += distance;
                            mesh.position.x = setx;
                            mesh.position.y = 0.6;
                            mesh.position.z = setz;
                        }
                        var pillcGeometry = new THREE.CubeGeometry(2.2, 2, 2.2, 1, 1, 1);
                        var pillcMaterial = new THREE.MeshBasicMaterial({ color: 0x003366, transparent: true, opacity: 0 });
                        var pillc = new THREE.Mesh(pillcGeometry, pillcMaterial);
                        pillc.position.x = mesh.position.x;
                        pillc.position.y = mesh.position.y;
                        pillc.position.z = mesh.position.z;
                        scene.add(pillc);
                        collidablePillList.push(pillc);

                    });
                }
            }

            //generate speed pills
            function spawnSpeeds(setx, setz) {
                loadOBJModel("models/", "speed.obj", "models/", "speed.mtl", (mesh) => {
                    speeds.push(mesh);
                    mesh.scale.set(15, 15, 15);
                    mesh.position.x = setx;
                    mesh.position.y = 2;
                    mesh.position.z = setz;
                    scene.add(mesh);

                    var Geometry = new THREE.CubeGeometry(3, 3, 3, 1, 1, 1);
                    var Material = new THREE.MeshBasicMaterial({ color: 0x003366, transparent: true, opacity: 0 });
                    var speedHitbox = new THREE.Mesh(Geometry, Material);
                    speedHitbox.position.x = mesh.position.x;
                    speedHitbox.position.y = mesh.position.y;
                    speedHitbox.position.z = mesh.position.z;
                    scene.add(speedHitbox);
                    collidableSpeedList.push(speedHitbox);
                });
            }
            //generate shrooms
            function spawnShrooms(setx, setz) {
                loadOBJModel("models/", "shroom.obj", "models/", "shroom.mtl", (mesh) => {
                    shrooms.push(mesh);
                    mesh.scale.set(0.3, 0.3, 0.3);
                    mesh.position.x = setx;
                    mesh.position.y = 0.2;
                    mesh.position.z = setz;
                    scene.add(mesh);

                    var Geometry = new THREE.CubeGeometry(3, 3, 3, 1, 1, 1);
                    var Material = new THREE.MeshBasicMaterial({ color: 0x003366, transparent: true, opacity: 0 });
                    var shroomHitbox = new THREE.Mesh(Geometry, Material);
                    shroomHitbox.position.x = mesh.position.x;
                    shroomHitbox.position.y = mesh.position.y;
                    shroomHitbox.position.z = mesh.position.z;
                    scene.add(shroomHitbox);
                    collidableShroomList.push(shroomHitbox);
                });
            }
            //generate weed
            function spawnWeeds(setx, setz) {
                loadOBJModel("models/", "weed.obj", "models/", "weed.mtl", (mesh) => {
                    weeds.push(mesh);
                    mesh.scale.set(0.6, 0.6, 0.6);
                    mesh.position.x = setx;
                    mesh.position.y = 0.15;
                    mesh.position.z = setz;
                    scene.add(mesh);

                    var Geometry = new THREE.CubeGeometry(3, 3, 3, 1, 1, 1);
                    var Material = new THREE.MeshBasicMaterial({ color: 0x003366, transparent: true, opacity: 0 });
                    var weedHitbox = new THREE.Mesh(Geometry, Material);
                    weedHitbox.position.x = mesh.position.x;
                    weedHitbox.position.y = mesh.position.y;
                    weedHitbox.position.z = mesh.position.z;
                    scene.add(weedHitbox);
                    collidableWeedList.push(weedHitbox);
                });
            }
            function spawnCrackMan(setx, setz) {
                //crackman model
                loadOBJModel("models/", "crackman.obj", "models/", "crackman.mtl", (mesh) => {
                    cmmodel = mesh;
                    cmmodel.scale.set(.08, .08, .08);
                    cmmodel.position.set(setx, -0.2, setz);
                    scene.add(cmmodel)
                });

                //CRACKMAN HITBOX
                var cubeGeometry = new THREE.CubeGeometry(2.5, 3, 2.5, 1, 1, 1);
                var wireMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0 });
                cmbox = new THREE.Mesh(cubeGeometry, wireMaterial);
                cmbox.position.set(setx, 0.6, setz);
                scene.add(cmbox);
            }
            function spawnGhost(setx, setz) {
                //ghost model
                loadOBJModel("models/", "ghost.obj", "models/", "ghost.mtl", (mesh) => {
                    var ghost = mesh;
                    ghost.scale.set(.002, .002, .002);
                    ghost.position.set(setx, 2, setz);
                    scene.add(ghost)
                    ghosts.push(mesh);
                });
                //ghost HITBOX
                var cubeGeometry = new THREE.CubeGeometry(2.5, 3, 2.5, 1, 1, 1);
                var wireMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0 });
                var gbox = new THREE.Mesh(cubeGeometry, wireMaterial);
                gbox.position.set(setx, 2, setz);
                scene.add(gbox);
                collidableGhostList.push(gbox);
            }

            //lower hp when hit
            function gethit() {
                life -= 10;
            }
            //rotates items
            function rotate(a) {
                a.rotation.z = a.rotation.z + 0.01;
            }
            //does something
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            //animates stuff
            function animate() {
                requestAnimationFrame(animate);
                render();
                if (life > 1) {
                    update();
                }
            }

            //render the scene and camera
            function render() {
                cameras();
                renderer.render(scene, camera);
            }

            //reset crackman and the camera
            function reset() {
                cmbox.position.set(46.5, 0.6, 7);
                cmmodel.position.set(46.5, 0, 7);
                cameratype = 2;
                speed = 0.3;
                pointss = 0;
                move = 'stop';
                for (var i = 0; i < collidablePillList.length; i++) {
                    collidablePillList[i].position.y = 0.6;
                    pills[i].position.y = 0.6;
                }
                for (var i = 0; i < collidableSpeedList.length; i++) {
                    collidableSpeedList[i].position.y = 2;
                    speeds[i].position.y = 2;
                }
                for (var i = 0; i < collidableShroomList.length; i++) {
                    collidableShroomList[i].position.y = 2;
                    shrooms[i].position.y = 0.2;
                }
                for (var i = 0; i < collidableWeedList.length; i++) {
                    collidableWeedList[i].position.y = 2;
                    weeds[i].position.y = 0.15;
                }
                collidableGhostList[0].position.set(9.5, 2, 23);
                collidableGhostList[1].position.set(47, 2, 16);
                collidableGhostList[2].position.set(84, 2, 7);
                collidableGhostList[3].position.set(40, 2, 59);
                collidableGhostList[4].position.set(17, 2, 69);
                collidableGhostList[5].position.set(70, 2, 54);
                collidableGhostList[6].position.set(70, 2, 37);
              
            }
            //switches between cameras
            function cameras() {

                if (cameratype == 1) { //free camera
                    camera.lookAt(50, 0, 37.5);
                }
                else if (cameratype == 2) { //3rd person camera
                    camera.lookAt(cmbox.position);
                    camera.position.z = cmbox.position.z - 20;
                    camera.position.y = cmbox.position.y + 20;
                    camera.position.x = cmbox.position.x;
                }
            }

            //object loader
            function loadOBJModel(modelPath, modelName, texturePath, textureName, onload) {
                new THREE.MTLLoader()
                    .setPath(texturePath)
                    .load(textureName, function (materials) {
                        materials.preload();

                        new THREE.OBJLoader()
                            .setPath(modelPath)
                            .setMaterials(materials)
                            .load(modelName, function (object) {
                                onload(object);
                            }, function () { }, function (e) { console.log("Error loading model"); console.log(e); });
                    });
            }
            exampleSocket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/connect_client");
            exampleSocket.onmessage = function (event) {
                var command = parseCommand(event.data);
            }
        }</script>
    <script src="three.min.js"></script>
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="MTLLoader.js"></script>
    <script src="OBJLoader.js"></script>

    <form action="end.php" method="post">
        Name: <input type="text" name="name" value="Name"> Points: <input readonly type="number" name="score" value="0" id="score"><input type="submit" value="Send Highscore">  <audio controls loop autoplay style="visibility:hidden; width: 10px; height:1px;"><source src="audio/music.mp3" type="audio/mpeg"></audio>
    </form>
    Health: <progress readonly id="health" value="150" max="150"></progress>

</body>
</html>
